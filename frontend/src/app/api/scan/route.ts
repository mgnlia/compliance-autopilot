import { NextRequest, NextResponse } from "next/server";
import Anthropic from "@anthropic-ai/sdk";

const client = new Anthropic();

// ---------------------------------------------------------------------------
// GitLab API v4 helpers
// ---------------------------------------------------------------------------

async function gitlabGet(path: string, token?: string) {
  const headers: Record<string, string> = { "Content-Type": "application/json" };
  if (token) headers["PRIVATE-TOKEN"] = token;
  const res = await fetch(`https://gitlab.com/api/v4${path}`, { headers });
  if (!res.ok) return null;
  return res.json();
}

function encodeProjectId(url: string): string {
  // https://gitlab.com/group/subgroup/project  →  "group%2Fsubgroup%2Fproject"
  const match = url.match(/gitlab\.com\/(.+?)(?:\.git)?(?:\/)?$/);
  if (!match) throw new Error("Cannot parse GitLab project URL: " + url);
  return encodeURIComponent(match[1]);
}

// ---------------------------------------------------------------------------
// Real GitLab data fetch
// ---------------------------------------------------------------------------

interface GitLabData {
  project: Record<string, unknown> | null;
  protectedBranches: unknown[];
  mergeRequests: unknown[];
  variables: unknown[];
  auditEvents: unknown[];
}

async function fetchGitLabData(projectUrl: string, token?: string): Promise<GitLabData> {
  let pid: string;
  try {
    pid = encodeProjectId(projectUrl);
  } catch {
    return { project: null, protectedBranches: [], mergeRequests: [], variables: [], auditEvents: [] };
  }

  const [project, protectedBranches, mergeRequests, variables, auditEvents] = await Promise.all([
    gitlabGet(`/projects/${pid}`, token),
    gitlabGet(`/projects/${pid}/protected_branches`, token),
    gitlabGet(`/projects/${pid}/merge_requests?state=merged&per_page=20`, token),
    gitlabGet(`/projects/${pid}/variables`, token),
    gitlabGet(`/projects/${pid}/audit_events?per_page=10`, token),
  ]);

  return {
    project: project ?? null,
    protectedBranches: Array.isArray(protectedBranches) ? protectedBranches : [],
    mergeRequests: Array.isArray(mergeRequests) ? mergeRequests : [],
    variables: Array.isArray(variables) ? variables : [],
    auditEvents: Array.isArray(auditEvents) ? auditEvents : [],
  };
}

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

interface Finding {
  id: string;
  severity: "critical" | "high" | "medium" | "low";
  framework: "SOC2" | "GDPR" | "HIPAA";
  control: string;
  title: string;
  description: string;
  remediation: string;
  artifact: string;
}

interface AgentLog {
  agent: string;
  action: string;
  result: string;
  duration_ms: number;
}

// ---------------------------------------------------------------------------
// Evidence generator
// ---------------------------------------------------------------------------

function generateEvidence(projectUrl: string, score: number, grade: string, findings: Finding[]): string {
  const criticals = findings.filter(f => f.severity === "critical").length;
  const highs = findings.filter(f => f.severity === "high").length;
  return `# Compliance Audit Evidence
**Project:** ${projectUrl}
**Scan Date:** ${new Date().toUTCString()}
**Score:** ${score}/100 (Grade ${grade})
**Generated by:** Compliance Autopilot — Claude-powered GitLab compliance agent

## Executive Summary
${criticals} critical and ${highs} high severity compliance drift issues detected across SOC2 and GDPR controls.

## Findings

${findings.map(f => `### ${f.id} — ${f.title}
- **Severity:** ${f.severity.toUpperCase()}
- **Framework:** ${f.framework} · ${f.control}
- **Description:** ${f.description}
- **Remediation:** ${f.remediation}
- **Artifact:** \`${f.artifact}\`
`).join("\n")}

## Remediation Priority
1. Address all CRITICAL findings within 24 hours
2. Address HIGH findings within 7 days
3. Schedule MEDIUM/LOW for next sprint

---
*This report was generated automatically by Compliance Autopilot using real GitLab API data. Review with your compliance team before submission to auditors.*`;
}

// ---------------------------------------------------------------------------
// Route handler
// ---------------------------------------------------------------------------

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { project_url, gitlab_token } = body as { project_url?: string; gitlab_token?: string };

  if (!project_url) {
    return NextResponse.json({ error: "project_url required" }, { status: 400 });
  }

  const agents_log: AgentLog[] = [];

  // ── PlannerAgent ──────────────────────────────────────────────────────────
  const plannerStart = Date.now();
  let gitlabData: GitLabData;
  try {
    gitlabData = await fetchGitLabData(project_url, gitlab_token);
  } catch {
    gitlabData = { project: null, protectedBranches: [], mergeRequests: [], variables: [], auditEvents: [] };
  }

  const dataAvailable = gitlabData.project !== null;
  const plannerSummary = dataAvailable
    ? `Fetched: project metadata, ${gitlabData.protectedBranches.length} protected branches, ${gitlabData.mergeRequests.length} merged MRs, ${gitlabData.variables.length} CI variables, ${gitlabData.auditEvents.length} audit events`
    : `GitLab API returned no data (project may be private — provide a token for full scan). Proceeding with structural analysis.`;

  agents_log.push({
    agent: "PlannerAgent",
    action: "Fetch GitLab project data via REST API v4",
    result: plannerSummary,
    duration_ms: Date.now() - plannerStart,
  });

  // ── ScannerAgent ──────────────────────────────────────────────────────────
  const scannerStart = Date.now();

  // Build a factual context string from real API data
  const apiContext = JSON.stringify({
    project_url,
    project: gitlabData.project
      ? {
          visibility: (gitlabData.project as Record<string, unknown>).visibility,
          default_branch: (gitlabData.project as Record<string, unknown>).default_branch,
          merge_requests_access_level: (gitlabData.project as Record<string, unknown>).merge_requests_access_level,
          approvals_before_merge: (gitlabData.project as Record<string, unknown>).approvals_before_merge,
        }
      : null,
    protected_branches: gitlabData.protectedBranches,
    merged_mrs_sample: gitlabData.mergeRequests.slice(0, 5).map((mr: unknown) => {
      const m = mr as Record<string, unknown>;
      return { iid: m.iid, merged_by: m.merged_by, approvals_count: (m as Record<string, unknown>).approvals_count ?? "unknown" };
    }),
    ci_variables_masked: gitlabData.variables.map((v: unknown) => {
      const variable = v as Record<string, unknown>;
      return { key: variable.key, masked: variable.masked, protected: variable.protected };
    }),
    audit_events_count: gitlabData.auditEvents.length,
  }, null, 2);

  const scannerMsg = await client.messages.create({
    model: "claude-opus-4-5",
    max_tokens: 1500,
    messages: [
      {
        role: "user",
        content: `You are ScannerAgent, a GitLab compliance analyst specializing in SOC2 and GDPR.

Below is REAL data fetched from the GitLab REST API v4 for this project. Analyze it for actual compliance violations. Do NOT invent findings — base every finding strictly on what the data shows. If data is null/missing, note it as "data unavailable" and flag it as a finding only if absence itself is a risk.

GitLab API Data:
${apiContext}

Return a JSON array of findings. Each finding must have:
- id: "F001", "F002", etc.
- severity: "critical" | "high" | "medium" | "low"
- framework: "SOC2" | "GDPR"
- control: e.g. "CC6.1", "Art. 32"
- title: short title
- description: what the data shows (cite specific values from the API data)
- remediation: concrete fix
- artifact: specific resource (branch name, MR IID, variable key, etc.)

Return ONLY a valid JSON array, no prose.`,
      },
    ],
  });

  const scannerText = (scannerMsg.content[0] as { text: string }).text;
  let findings: Finding[] = [];
  try {
    const jsonMatch = scannerText.match(/\[[\s\S]*\]/);
    if (jsonMatch) findings = JSON.parse(jsonMatch[0]);
  } catch {
    findings = [];
  }

  agents_log.push({
    agent: "ScannerAgent",
    action: "Analyze GitLab API data for SOC2/GDPR violations",
    result: `Found ${findings.length} findings based on real project data`,
    duration_ms: Date.now() - scannerStart,
  });

  // ── AnalyzerAgent ─────────────────────────────────────────────────────────
  const analyzerStart = Date.now();
  const criticals = findings.filter(f => f.severity === "critical").length;
  const highs = findings.filter(f => f.severity === "high").length;
  const mediums = findings.filter(f => f.severity === "medium").length;
  const lows = findings.filter(f => f.severity === "low").length;
  const score = Math.max(0, Math.min(100, 100 - criticals * 25 - highs * 15 - mediums * 8 - lows * 3));
  const grade = score >= 90 ? "A" : score >= 75 ? "B" : score >= 60 ? "C" : score >= 45 ? "D" : "F";

  agents_log.push({
    agent: "AnalyzerAgent",
    action: "Calculate compliance risk score",
    result: `Score: ${score}/100 (${grade}) — ${criticals} critical, ${highs} high, ${mediums} medium, ${lows} low`,
    duration_ms: Date.now() - analyzerStart,
  });

  // ── ReporterAgent ─────────────────────────────────────────────────────────
  const reporterStart = Date.now();
  const evidenceMarkdown = generateEvidence(project_url, score, grade, findings);
  agents_log.push({
    agent: "ReporterAgent",
    action: "Generate audit evidence bundle",
    result: `Evidence report generated: ${findings.length} findings documented`,
    duration_ms: Date.now() - reporterStart,
  });

  return NextResponse.json({
    project_url,
    score,
    grade,
    findings,
    evidence_markdown: evidenceMarkdown,
    agents_log,
    scanned_at: new Date().toISOString(),
    data_source: dataAvailable ? "gitlab_api_v4" : "claude_analysis_only",
  });
}
